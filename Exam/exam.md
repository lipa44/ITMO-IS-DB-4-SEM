# БД Экз

## 1. База данных как компонент информационной системы. Определение понятия данные, функции ИС. Абстрагирование данных от методов их обработки. Многозвенная архитектура ИС

**Информационная система** - совокупность аппаратных и программных компонентов, связанных с обработкой информации (ПО + данные + люди + железо)

**Данные** - это поддающиеся многократной интерпретации представления информации в **формализованном** виде, пригодные для передачи, интерпретации и обработки

(с) ISO стандарт

**Функции ИС**

1. Сбор
2. Хранение
3. Обработка
4. Представление
5. Прередача

> Данные **абстрагируются** от бизнес-логики, в связи с этим возникают проблемы с доступом к данным

Если есть много приложений, которые хотят обратиться к данным, доступ будет выдан единовременно только одному приложению - иначе возникает риск тупиков.

> Над данными надстраивается слой, который нам обеспечивает доступ к данным - СУБД

Получаем следующую структуру: Клиент - БизнесЛогика - Доступ к данным (Данные)

**Система управления базами данных (СУБД)** — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных

**Многозвенная архитектура** - это архитектура, подразумевающая разделение компонентов на функциональные группы

Порядок выполнения запроса в многозвенной архитектуре будет следующим: `Запрос -> СУБД -> БД`

<br>

## 2. Определения базы данных и СУБД по Конноли, Дейту и Хомоненко. Их сходства и различия

### Определения базы данных

**База данных** - это совместно используемый набор логически связанных данных, и описание этих данных, предназначенные для удовлетворения информационных потребностей организаций. **(с) Коннолли и Бегг**

**База данных** - это набор постоянно хранимых данных, используемых прикладными системами какого-либо предприятия. **(с) Дейт**

**База данных** - это совокупность специальным образом организованных данных, хранимых в памяти вычислительной системы, и отображающих состояния объектов и их взаимосвязей в рассматриваемой предметной области. **(с) Хомоненко**

### Определения СУБД

**СУБД** - программное обеспечение, с помощью которго пользователи могут опеределять, создавать и поддерживать базу данных, а также осуществлять к ней контролируемый доступ **(с) Коннолли и Бегг**

**СУБД** - Программное обеспечение, которое управляет всем доступом к базе данных **(с) Дейт**

**СУБД** - это комплекс языковых и программных средств, предназначенный для создания, ведения и совместного использования базы данных многими пользователями  **(с) Хомоненко**

### Различия в определениях

1. **БД**: Конноли и Дейт рассматривают применение базы данных в контексте организации, в то время как Хомоненко даёт более общее определение

2. **СУБД**: во всех определениях СУБД осуществляет контроль доступа к БД

<br>

## 3. Файловые хранилища. Недостатки. Упорядоченные и неупорядоченные файлы

### Файловые хранилиза. Недостатки

Развитие ПО идёт по пути абстрагирования данных от их обработки. Появляется вопрос — **где хранить данные?**

#### 1. В файле

- Проблема разделения доступа к данным и сохранения целостности

#### 2. В нескольких файлах

- **Дедлок**. Образование бесконечной блокировки (для одного файла блокировка конечная)
  - Чтобы это избежать, в БД существуют транзакции

- **Дублирование данных**.
  - Один из путей избавления — нормализация данных

- **Зависимость от типа**.
  - Например, долгий переход от ext3 к ext4 (из-за максимального размера файла 2 Тб в ext3)

- **Формат файла**.
  - Различные (в т.ч. новые) разработчики должны соблюдать формат файла

### Упорядоченные и неупорядоченные файлы

1. **Неупорядоченный** — новый факт в конец файла.
    - Быстрая запись, медленное чтение

2. **Упорядоченный** — сортировка по атрибуту.
    - Не очень-то быстрое чтение и запись

<br>

## 4. Трехуровневая архитектура ANSI/SPARC

Стандарт **ANSI/SPARC** - подход построения архитектуры.
В ней выделяется три слоя архитектуры.

### Уровни архитектуры ANSI/SPARC

1. Внешний у-нь
2. Концептуальный у-нь
3. Внутренний у-нь

### Внешний у-нь

Представление БД с позиции конечного пользователя _(смотрит на человека)_.

1. Определяется обьем и форма представления данных для принятия решения.
2. _Это не про хранение данных_, это про то как принимать эффективные решения на основе данных.

### Концептуальный у-нь

Обобщающее представление БД (то как данные хранятся и какая между ними связь/_смотрит на железо_).

1. Решение о том, какие данные и как они должны хранится _(например, статус будет храниться в числах или в строках)_.
2. Какие ограничения на эти данные накладываются _(проверка регулярными выражениями)_.

### Внутренний у-нь

Физическое представление БД с точки зрения конкретного инструмента.

1. Распределение данных по дисковому пространству
2. Структуры хранения данных
3. Как реализуется безопастность хранения данных (шифрование)
4. Сжатие данных, оптимизация памяти

> Таблица == отношения (relations)

**ANSI/SPARC** подразумевает учет всех трех уровней при приоектировании

**ANSI/SPARC** -> Уровни моделей данных

<br>

## 5. Модель сущность-связь. Классификация сущностей, атрибутов и связей. Нотация Чена для представления модели сущность-связь

> ER(A) - _сущность-отношение-атрибуты_

**Сущность** - _множество экземпляров: реальных или абстрактных однотипных предметов предметной области_

**Сильная сущность** - _может существовать независимо от остальных_

**Слабая сущность** - _может существовать только вместе с другой (сильной)_

У **сущности** могут быть **атрибуты** (свойства сущности)

**Атрибуты**:

1. Простые - номер
2. Составные - адресс, населенный пункт и тд
3. Обязательные атрибуты - однозначно индетифицировать сущность
4. Необязательные атрибуты
5. Однозначные
6. Многозначные

**Типы связей**:

1. Один к одному
2. Один ко многим
3. Многие со многим

> Нотация Чена - это правила обозначения сущностей, атрибутов связей и тд в виде диаграм.

### Нотация Чена

1. Сущности изображаются прямоугольником
    - Прямоугольник, соответствующий слабой сущности, обводится двойной рамкой

2. Атрибуты изображаются в виде овала, соединенного с соответствующим прямоугольником
    - Ключевые атрибуты выделяются подчеркиванием или служебным символом в начале имени

3. Связь обозначается ромбом
    - Ромб окружен двойной линией, если связь задана между слабой сущностью и сущностью, от которой она зависит

![Нотация чена](../Images/Chen-notation.jpg)

<br>

## 6. Логическая и физическая модели данных. Содержание уровней

### Логическая (даталогическая) модель

Определяет **способ** организации данных (концепцию), а **не конкретную реализацию**.

Набор схем отношений, обычно с указанием первичных ключей, а также связей между отношениями, представляющих собой внешние ключи. Учитывается специфика конкретной модели данных, но не учитываться специфика конкретной СУБД.

1. Иерархическая
2. Сетевая
3. Реляционная
4. ... еще какие-то Маятин не сказал

### Физическая модель

Сопоставима с внутренним уровнем (построение часто автоматизировано).

Создание схемы базы данных для конкретной СУБД: Выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов.

1. Определяем всевозможные ограничения в названиях и т.п
2. Ограничения на типы данных (доменты атрибутов)
3. Индексы и всё такое
4. Разделение на отдельные файлы, партиции

<br>

## 7. Иерархическая и сетевая модели данных: составы моделей, преимущества и недостатки

### Иерархическая модель

> Существует только 2 типа связи: `A Kind Of` / `A Part Of`

#### Компоненты иерархической модели

1. **Поле данных (аттрибут)** - минимальная неделимая, уникально адресуемая единица хранения данных

2. **Сегмент данных (запись/record/экземпляр данных)** - совокупность полей данных, имеющая уникальную идентификацию (сущность в модели ER).

3. Экземпляр сегмента — конкретные значения полей

4. Дерево — совокупность сегментов, связанных с помощью связи родитель-потомок

![Иерархическая модель](../Images/%D0%B8%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.jpg)

**Плюсы:**

1. Более эффективное использование памяти, **относительно** простого хранения данных без какой-либо структуры

2. Более быстрое время выполнения CRUD операций, **относительно** простого хранения данных без какой-либо структуры

**Проблемы:**

1. Требуется много памяти для хранения _(производительность)_
2. Сложно контролировать целостность данных
3. Дублирование данных
4. Скорость операций записи
5. Огромные трудности при реорганизации структуры (иерархии)
6. Невозможна связь `Many-to-many`

### Сетевая модель

- Можно ссылаться много раз на один и тот же объект
- Разделяем хранение связей от хранения данных

**Агрегаты** — так называют сегменты

![Сетевая модель](../Images/%D1%81%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.jpg)

**Плюсы:**

1. Обеспечивает атрибутивную целостность

**Проблемы:**

1. Храним сущности и связи отдельно
2. Появилась проблема ссылочной целостности

<br>

## 8. Реляционная и постреляционная модели данных: составы моделей, преимущества и недостатки

### Реляционная модель

Реляционная — relationship (таблица — отношение)

![Реляционная модель](../Images/%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png)

#### Компоненты реляционной модели

1. **Поле данных** - неделимая, уникально адресуемая единица хранения данных

2. **Отношение** - совокупность множества полей данных

3. **Связь** - хранение с помощью ключа, хранение связи = пара ключей + вес

**Один ко многим** : добавляем ID на продукт (другую сущность)

**Многие ко многим:** отдельная сущность с ID_1, ID_2, другое поле

#### Нововведения

1. Связи хранятся в отдельных отношениях _(таблицах)_
2. Фактически от сетевой модели к реляционной мы переходим, реорганизовав хранение связей _(но не только)_

3. Возникают предпосылки для избежания дублирования данных
4. Позволяет гарантировать целостность данных (при грамотной организации)

5. Позволяет гарантировать избежание дублирвоания данных (при грамотной организации)

6. Позволяет гарантировать эффективное времы выполнения операций записи (при грамотной организации)

> **Сама таблица - тоже связь**

**Плюсы:**

1. Более эффективное использование памяти, **относительно** сетевоой и иерархической моделей

2. Более быстрое время выполнения CRUD операций, **относительно** сетевоой и иерархической моделей

**Проблемы:**

1. **Поле** - неделимый элемент данных, поэтому возникает проблема с определением типа данных и их хранением

### Постреляционная модель

> Фактически это реляционная модель, но без целостности данных - поле данных может само по себе являться агрегатом (снимаем требование неделимости с отдельного поля)

Поле данных - _агрегат_

**Плюсы:**

1. Представление данных становится наглядным и нет необходимости соединять таблицы.

**Проблемы:**

1. При нормализации отношенией не гарантируется получение целостных данных, так как мы выносим данные из понятия отношений

2. Целостность данных ложится на плечи разработчиков

3. При большом количестве данных все алгоритмы в основном работают за `O(e)`

> Появилась идея о том, что скорость вычисления намного чажнее, чем память.

<br>

## 9. Многомерная и объектно-ориентированная модели данных: составы моделей, преимущества и недостатки

### Многомерная модель

#### Нововведения

Данные организованы не в виде множества связанных двумерных таблиц, а в виде упорядоченных многомерных массивов.

**Срез** — подмножество гиперкуба, полученное путём фиксации одного или нескольких измерений.

1. Позволяет быстро искать данные
2. Ускоряет работу с СУБД (хранит таблицы фактически с кешем)

**Плюсы:**

1. Поиск и извлечение данных производятся гораздо быстрее за счёт того, что многомерная БД денормализована и содержит заранее вычесленные агрегаты.
2. Более простая процедура встраивания функций в многомерную БД
3. Стоимость поддержки ниже, чем у реляционной

**Проблемы:**

1. Неэффективно по памяти
2. Отсутствие значения приведёт к пустой “линии” в “кубе” данных **(olap кубы)**
3. **Olap кубы** очень сложно изменять с точки зрения структуры _(добавляется измерение)_

4. Актуальность кеша

> Сама таблица - связь, все записи - продукты, их объединяет множественное отношение.

### Объектно-ориентированная модель

Иерархическая структура, узлами которой являются объекты.

Между записями устанавливаются связи, подобные связям в ООП. Свойства объектов описываются либо одним из стандартных типов или собственным классом.

#### Нововведения

1. Можем хранить объекты целиком, не разбрасывая его на разные таблицы
2. Улучшается производительность в ООП приложениях
3. Удобно с точки хрения распределённых систем

**Плюсы:**

1. Не нужно знать о взаимодействии объектов, просто обращаемся к конкретному.
2. Возможность идентифицировать отдельные записи в базе

**Проблемы:**

1. Зацикливаемся на ООП парадигме
2. Вопрос целостности данных ложится на код
3. Низкая скорость выполнения запрсосов

<br>

## 10. Реляционная модель данных: терминология, свойства отношения

> Основой реляционной базы данных является понятие отношения.

### Терминология

> Отношение - плоская таблица.

**Схема отношения** - первая строка таблицы (заголовок столбцов)

**Кортеж** - это отдельная строка в таблице

**Аттрибут** - это отдельный столбец в таблице

**Поле данных** - пересечение кортежей и аттрибутов

**Домен** - множество допустимых значений аттрибута

**Степень отношения** - количество аттрибутов _(столбцов)_

**Координльность соотношения** - количество кортежей _(строк)_

### Свойства отошения

1. Уникальность имени отношения в реляционной схеме _(каждая таблица имееет уникальное имя)_
2. Каждая ячейка содержит только одно неделимое значение
3. Уникальность имени аттрибута в пределах отношения
4. Значение любого аттрибута берутся из одного и того же домена
5. Каждый кортеж уникален
6. Порядок следования аттрибутов и порядок следования кортежей не имеют значения (депрекейтед из-за производительности)

> В реляционной модели хранятся только отношения _(без связей)_, все объекты однотипны

<br>

## 11. Реляционная модель данных: виды ключей, реализация различных типов связей, виды целостности

### Виды ключей

**Суперключ** - это аттрибут или множество аттрибутов, единственным образом идентифицирующие кортеж.

> _Всё множество аттрибутов само по себе является **суперключом**._

**Потенциальный ключ** - это суперключ, который не содержит модмножество, также являющегося суперключом _(суперключ минимального размера)_.

> _Потенциальный ключ может быть **простым** и **составным**._

**Первичный ключ (Primary Key)** - это один из потенциальных ключей, который выбран для уникальной идентификации кортежей данного отношения.

**Внешний ключ (Foreign Key)** - это аттрибут или множество аттрибутов, которое соответствует потенциальному ключу некоторого, может быть, того же самого отношения.

### Типы связей

#### 1. Один-к-одному

Первичный ключ одного из отношений является одновременно и внешним ключём.

> Есть таблица работников, и таблица менеджеров по продажам. Id работника будет `PK`, который взят из `PK` менеджера. Таким образом, Id менеджера - это `PK` и `FK` одновременно.

**Employee**

| Id_Emp (`PK`) | Id_Boss (`FK`) | Other fields |
| :-----------: |:--------------:| :-----------:|
|       2       |        1       |     field    |

**SalesPerson**

| Id_SalesPerson (`PK`, `FK`) | Other fields |
| :-------------------------: | :-----------:|
|           1, 2              |     field    |

#### 2. Один-к-многим

> Есть таблица групп и студентов. Значение Id группы у студента будет `FK`, который взят из Id, то есть `PK` группы.

**Student**

| Table_Number | LastName | MiddleName | FirstName | Group_Id (`FK`) |
| :----------: |:--------:| :---------:| :-------: | :-------------: |
|       1      |  Кудашев | Эдуардович |  Искандер |       32011     |

**Group**

| Group_Id (`PK`) |  Other fields |
| :-------------: | :-----------: |
|      32011      |      field    |

#### 3. Много-ко-многим

Обычно используются таблицы-связки, хранящие связи по Id.

> Есть менеджеры, каждый из которых продаёт продукты. Создаём таблицу с `PK` продукта и менеджера.

### Виды целостности

1. Сущностная целостность - в отношении ни один аттрибут `PK` не может содержать `NULL` значение
2. Ссылочная целостность - если в отношении существует `FK`, то значение этого ключа должно соответствовать существующему значению `PK` в другом отношении

<br>

## 12. Операции реляционной алгебры: проекция, выборка, объединение, разность, пересечение

### Унарные

#### 1. Проекция - `П_{a_1, a_2, a_3, ..., a_n}(R)`

**Проекция** (`SELECT`) - это операция, которая определяет новое отношение, содержащее вертикальном подмножество исходного отношения, создоваемое посредством извлечения значений указанных аттрибутов и исключения из резуьтата строк-дубликатов.

#### 2. Выборка - `S_{предикат}(R)`

**Выборка** (`WHERE`) - это операция, которая определяет результирующее отношение, которое содержит только те кортежи из исходного отношения, которые удовлетворяют заданному условию _(предикату)_.

### Бинарные

#### 3. Объединение - `R u S`

**Объединение** (`UNION`) - это операция над отношениями R и S, определяющая **новое** отношение, которое включает все кортежи, содержащиеся только в R, все кортежи, содержащиеся только в S и кортежи, содержащиеся одновременно в R и S с исключением дубликатов.

> Объединение возможно только, если отношения совместимы, и обычно объединение считается **опасной операцией**

**Совместимость по объединению** - два отошения R и S будут совместимы по объединению, когда они состоят из одинакового кол-ва аттрибутов, и каждая пара соответствующих аттрибутов будет иметь одинаковый домен.

#### 4. Разность - `R - S`

**Разность** - это отношение, состоящее из кортежей, которые есть в отношении R, но отсутствуют в отношении S

> Данная операция требует, чтобы отношения были совместимы по объекдинению

#### 5. Пересечение - `R ^ S`

**Пересечение** - это отношение, которое определяет кортежи, присутствующие в обоих отношениях одновременно

<br>

## 13. Операции реляционной алгебры: Тета-соединение, эквисоединение, естественное соединение, левое внешнее соединение, полусоединение

### Небинарные

#### 1. Декартово произведение - `R x S`

**Декартово произведение** - определяет новое отношение, которое является результатом конкатенаци каждого кортежа из отношения R с каждым кортежем из отношения S.

#### 2. Тета-соединение - `R _f S`, где `f = R * a_i (Theta) S * b_i, (Theta) = { <, <=, =, >, >= }`

**Тета-соединение** (`R _f S`) - определяет новое отношение, которое содержит кортежи из декартова произведения отношений R и S, удовлетворяющие предикату f

___

> Дополнительные операции, не реализованные в `SQL`

#### 3. Экви-соединение

**Экви-соединение** - это тета-соединение, где (theta) - это операция равно

#### 4. Естественное соединение - `R _ S`

**Естественное соединение** - это соединение по эквивалентности двух отношений, выполненное по всем общим аттрибутам, из результатов которого исключается по одному экземпляру каждого общего аттрибута.

#### 5. Левое внешнее соединение - ``

**Левое внешнее соединение** - это тета-соединение, при котором в результирующее отношение включаются также кортежи отношения R, не имеющие совпадающих значений в общих столбцах отношения S.

#### 6. Полу-соединение

**Полу-соединение** - определяет отношение, содержащее только те кортежи из R, которые входят в соединение R и S

<br>

## 14. Структура и порядок выполнения предложения Select в SQL

### Как выглядит SELECT

```sql
SELECT [DISTINCT | ALL] { * | [ColumsExpression [AS NewName], ... ] }
FROM TableName [AS NewName]
    [ { INNER | LEFTOUTER | FULL } JOIN ] TasbeName2 [AS NewName]
    ON condition ]
[ WHERE condition ]
[ GROUP BY ColumnList ]
[ HAVING condition ]
[ ORDER BY ColumnList [ ASC | DESC ]]
```

### Последовательность выполнения SELECT

1. `FROM`
2. `JOIN ... ON`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `SELECT`
7. `DISTINCT`
8. `ORDER BY`

<br>

## 15. Алгоритмы реализации соединений отношений в SQL

Для того, чтобы обеспечить целостность, мы будем заниматься денормализацией _(создавать множество связанных таблиц)_.

Это приводит к снижению **производительности**.

> Соединение таблиц - это дорого!

### 1. Неэффективно (декартово произведение)

> Вложенный цикл

```csharp
for (int i = 0; i < R.Count; ++i)
{
    for (int j = 0; j < S.Count; ++j)
    {
        if (R[i].atr != S[j].atr) continue;
        Console.WriteLine(r + s);
    }
}
```

```py
for r in R
    for s in S
        if (r.atr == s.atr)
            print(r + s)
```

### 2. Эффективно

> Предварительная сортировка

```py
R.sort(atr)
S.sort(atr)

while not EndOF(S) ans not EndOF(R)
    if (r.atr < s.atr)
        next(R)
    if (r.atr = s.atr)
        print(r + s)
        next(R)
    if (r.atr > s.atr)
        next(S)
```

<br>

## 16. Нормализация реляционной модели: избыточность, аномалии, суть метода нормальных форм. Виды зависимостей между атрибутами

**Нормализация** - преобразование отношения к виду, отвечающему нормальной форме.

> **Нормальная форма** - некоторая характеристика отношения.

У нормальных форм есь иерархия: каждая следующая является предыдущей.

### Избыточность

**Студент**

|     Фио     | Группа | Образовательная программа |
| :---------: |:------:| :------------------------:|
| Либченко М. | M32011 |      Программирование     |

> Образовательная программа хранится либо у одного студента, либо у всех сразу. В обоих случаях это приводит к своим издержкам.

### Аномалия

#### 1. Модификации

**Аномалия модификации** - изменение значения одной записи привлечёт за собой просмотр всей таблицы и изменения некоторых других записей.

#### 2. Удаления

**Аномалия удаления** - при удалении записи может пропасть и другая информация.

#### 3. Добавления

**Аномалия добавления** - информацию в таблицу нельзя поместить, пока она неполная или требуется дополнительный просмотр табиц.

> Аномалии потенциально приводят нас к нарушению целостности данных.

### Решение проблемы аномалии

**Расширенная таблица студентов**

|  Фио `(PK)` | Группа `(PK)` | Образовательная программа |  Факультет  | Форма обучения |
| :---------: |:-------------:| :-----------------------: |:-----------:| :------------: |
| Либченко М. |     M32011    |      Программирование     |     ФИТиП   |      Очная     |

### Виды зависимостей между атрибутами

#### Функциональная зависимость между аттрибутами

**Функциональная зависимость между аттрибутами** `(X -> Y)` - в отношении R атрибут y функцинально зависит от атрибута x тогда и только тогда, когда каждому значению x соответствует в точности одно значение y.

> Факультет функционально зависит от образовательной программы.

#### Частичная функциональная зависимость

**Частичная функциональная зависимость** `(ФИО + Группа) -> Образовательная программа` - зависимость неключевого атрибута от часть составного ключа.

#### Полная функциональная зависимость

**Полная функциональная зависимость** `(ФИО + Группа) -> Форма обучения` - неключевой атрибут зависит от всего составного ключа.

#### Транзитивная функциональная зависимость

**Транзитивная функциональная зависимость** `(X -> Z, Y: X -> Y && Y -> Z)` - существует такое множество атрибутов Y, что выполняется требование о существовании зависимостей `X -> Y && Y -> Z)`

<br>

## 17. Первая и вторая нормальные формы. Примеры

### Первая нормальная форма

Отношение находится в первой нормальной форме, если все его атрибуты явзяются простыми.

> ФИО мешает нашей таблице соответствовать первой нормальной форме. Для того, чтобы таблица студента находилась в ПНФ, необходимо разделить столбец ФИО на 3 столбца: Ф, И, О

### Вторая нормальная форма

Отношение находится во второй нормальной форме, если оно находится в первой нормальной форме, и каждый неключевой атрибут **функционально полно** зависит от первичного ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  Л. |  М. |  В. |  M32011  |      Очная     |

| Группа | Образовательная программа |  Факультет  |
| :----: | :-----------------------: | :---------: |
| M32011 |      Программирование     |    ФИТиП    |

<br>

## 18. Третья нормальная форма. Примеры

### Третья нормальная форма

1. Отношение находится в третьей нормальной форме, если оно находится во второй нормальной форме, и все неключевые атрибуты взаимно независимы и полностью зависят от первичного ключа.

2. Отношение находится в третьей нормальной форме, если оно находится во второй нормальной форме, и ни один ключевой атрибут не находится в транзитивной функциональной зависимости от потенциального ключа.

|  Ф  |  И  |  О  |  Группа  | Форма обучения |
| :-: | :-: | :-: | :------: | :------------: |
|  К. |  И. |  Э. |  M32011  |      Очная     |

| Группа | Образовательная программа |
| :----: | :-----------------------: |
| M32011 |      Программирование     |

| Образовательная программа | Факультет |
| :-----------------------: | :-------: |
|      Программирование     |   ФИТиП   |

<br>

## 19. Нормальная форма Бойса-Кодда. Примеры

### Нормальная форма Бойса-Кодда

**Проекты**

|  Номер студента  |     ФИО    |  Номер проекта  |  Роль  |
| :--------------: | :--------: | :-------------: | :----: |
|       307484     | Кудашев И. |         1       | Бекенд |

> Данное отношение не соответствует НФ Бойса-Кодда

Отношение находится в нормальной форме Бойса-Кодда, если детерминанты _(зависимые части)_ всех зависимостей являются потенциальными ключами.

#### Приведение к нормальной форме Бойса-Кодда

| Студент | Номер студента |    ФИО    |
| :-----: | :------------: | :-------: |
| Кудашев |      307484    |  К. И. Э. |

|  Номер студента  |  Номер проекта  |  Роль  |
| :--------------: | :-------------: | :----: |
|       307484     |         1       | Бекенд |

<br>

## 20. Четвертая нормальная форма. Примеры

### Четвёртая нормальная форма

Отношение находится в четвёртой нормальной форме, если оно находится в нормальной форме Бойса-Кодда, и не содержит многозначных зависимостей.

|  Дисциплина |    Лектор    |    Практик   |
| :---------: | :----------: | :----------: |
| Базы данных | Маятин А. В. | Маятин А. В. |

> Не соответствует четвёртой нормальной форме, но соответствует всем предыдущим

#### Приведение к четвёртой нормальной форме**

**Лекторы**

|  Дисциплина |     Лектор   |
| :---------: | :----------: |
| Базы данных | Маятин А. В. |

**Практики**

|  Дисциплина |    Практик    |
| :---------: | :-----------: |
| Базы данных |  Маятин А. В. |

> Вопрос приведения к четвёртой нормальной форме - вопрос **интерпритации** данных.

<br>

## 21. Использование индексов для повышения производительности. Виды индексов

> Индекс - это механизм, который направлен на оптимизацию поиска.

Таблица №1

| Табельный |     ФИО     | Группа |
| :-------: | :---------: | :----: |
|  308372   | Либченко М. | M32011 |

Таблица №2

| Группа |   О. Программа   |
| :----: | :--------------: |
| M32011 | Программирование |

**Индекс** - это метод, который позволяет получить структуру данных, предназначенную для оптимизации поиска.

Как выглядит индекс:

| Ключ | Значение (адрес кортежа в таблице) |
| :--: | :--------------------------------: |
| key  |                value               |

### Варианты индексов

#### 1. **Первичный индекс**

Файл упорядочен по первичному ключу, и по нему же построен индекс, так что гарантируется уникальность каждой записи (кортежа)

| Ключ (Табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|      308372      |               value                |

Этот индкс можно переформатировать в какую-нибудь структуру данных, например, **красно-чёрное дерево**

- **Хеш** индекс

| Ключ (хеш табельного) | Значение (адрес кортежа в таблице) |
| :-------------------: | :--------------------------------: |
|       hashValue       |                value               |

> Для избавления от коллизий делаем ключ огромного размера

#### 2. **Кластеризованный** индекс

Файл упорядочен по ключевому или неключевому атрибуту, по которому построен индекс, при этом несколько кортежей (кластер) соответствует одному значению индекса.

| Ключ (хеш от ФИО) | Значение (адрес кортежа в таблице) |
| :---------------: | :--------------------------------: |
|       hashValue   |               value                |

#### 3. **Вторичный** индекс

Индекс, который построен по аттрибуту, отличному от того, по которому осуществлено упорядочивание

> Первый вариант

| Ключ (табельный) | Значение (адрес кортежа в таблице) |
| :--------------: | :--------------------------------: |
|       308372     |                value               |

При этом у нас сама таблица отсортирована по ФИО.

> Проблема заключается в том, что нам может понадобиться часто балансировать структуры (деревья)

> Второй вариант

| Ключ (табельный) | Коэф сбалансированности | Значение (адрес кортежа в таблице) |
| :--------------: | :---------------------: | :--------------------------------: |
|       308372     |        balanceValue     |                value               |

### Классы индексов

1. `Плотный` - охватывает все записи
2. Разреженный - охватывает только записи, находящиеся в блоке

<br>

## 22. Использование представлений для повышений производительности и безопасности. Виды представлений. Преимущества и недостатки представлений

**Представление** - это динамически сформированный результат одной или нескольких реляционных операций, выполненных над отношениями с целью получения нового отношения.

Таблица №1

| Табельный | ФИО | Группа | Паспорт |
| :-------: | :-: | :----: | :-----: |
|   308372  | Либченко М.| M32011 | не скажу |

Таблица №2

| Группы | О. Программа |
| :----: | :----------: |
| M32011 | Программирование |

Таблица №3

| О. Программа | Факальтет |
| :----------: | :-------: |
| Программирование | ФИТиП |

Появляется идея о том, чтобы закешировать часто используемые вместе данные

Закешированная таблица

| Табельный | ФИО | Группа | О. Программа | Факультет |
| :-------: | :-: | :----: | :----------: | :-------: |
|   308372  | Либченко М. | M32011 | Программирование | ФИТиП |

### Материализованные представления

**Материализованное представление** - храним дубликаты данных, полученные в результате выполнения некоторого запроса, **непосредственно** в памяти

### Представления замены

**Представление замены** - хранится только подзапрос, который выполняется когда нужно выполнить родительский запрос, и просто отдаёт в этот родительский запрос нужные данные.

> Выигрываем по безопасности

Тут мы делаем представление, ограничивая выдаваемые данные, засчёт чего обеспечиваем безопасность

### Типы представлений

1. Обновляемые
2. Необновляемые

### Преимущества представлений

1. Независимость от данных
2. Повышение защищённости данных
3. Снижение сложности запросов

### Недостатки представлений

1. Ограниченные возможности представлений
2. Структурные ограничения
3. Снижение производительности

<br>

## 23. Транзакции. Понятие транзакции. Свойства транзакции

**Транзакция** - последовательность действий с базой данных, в которой либо все действия выполняются успешно, либо не выполняется ни одно из них. 

> По факту это преобразование бд из одного логически-согласованного состояния в другое логически-согласованного состояния, подразумевая, что в промежутке бд могла находиться в логически-несогласованном состоянии

### Свойства транзакций

Выполнение всех четырёх свойств одновременно гарантирует надёжность операций

1. Атомарность

    Транзакция неделима, т.е. либо выполняются все её действия, либо ни одного

2. Согласованность

    Транзакция переводит одно согласованное состояние бд в другое без соблюдения обязательной согласованности в промежуточных точках

3. Изоляция

    Если запущено несколько конкурирующих транзакций, то любое обновление состояния бд, выполненное одной транзакцией, скрыто от других до её завершения

4. Долговечность

    Когда транзакция завершена, её результаты обновления сохраняются, даже если в следующий момент произовдёт сбой

<br>

## 24. Проблемы конкурирующих транзакций и методы их решения. Уровни изоляции транзакций

### Проблемы конкурирующих транзакций

1. Проблема потерянного обновления

    Несколько транзакций меняют один и тот же кортеж, в результате сохраится только резльтат внесения изменений последенй транзакции.

    > Кладём и списываем деньги со всёта

2. Проблема грязного чтения

    При чтении одной транзакции кортежа, который уже изменён, но ещё не сохранён другой уже завершившейся транзакцией, которая будет потом отменена.

    > Кладём и списываем деньги со счёта, после этого пытаемся отменить пополнение

3. Проблема неповторяемого чтения

    При повторном чтении данных, уже считанных ранее, транзакция обнаруживает модификацию, вызванную другой завершённой транзакции.

4. Проблема фантомного чтения

    При повторной выборке, выполняющий некоторый запрос, могут попасть новые кортежи

    > Сначала считываем данные, потом добавляем новую запись и на основе считанных данных получаем неверный результат (например, среднее значение в параллельных подзапросах)

### Блокировки

> Все транзакции строятся на основе блокировок - блокировки кортежей, аттрибутов, таблиц или всей базы данных

#### Классификация блокировок

1. Явные (накладывающиеся пользователем)

2. Неявные (накладывающиеся самой СУБД)

3. Монопольные - блокируются все виды доступа к объектам

4. Коллективные - блокируются доступ к чтению? к объектам

Дедлоки

> Если одна из транзакций пытается наложить блокировку, пересекающиеся с какой-то другой блокировкой - появление **дедлоков**

### Уровни изоляции (для решения конкурирующих транзакций)

1. Незавершённое чтение

    Требует, чтобы изменять данные могла только одна транзакция. Поможет справиться с **проблемой потерянного обновления**.

2. Завершённое чтение

    Если транзакция начала изменение данных, то никакая другая транзакция не сможет их прочитать до завершения первой. Поможет справитсья с **проблемой грязного чтения**.

3. Воспроизводимое чтение

    Если транзакция считывает данные, то никакая другая транзакция не сможет их изменить до завершения первой. _Видимо_, поможет справиться с **проблемой неповторяемого чтения**

4. Сериализуемость

    Если транзакция обращается к данным, то никакая другая транзакция не сможет добавить новые или изменить существующие кортежи в этом объекте данных. _Видимо_, поможет справиться с **проблемой фантомного чтения**

### Долговечность

Обеспечивается журналируемостью транзакций

<br>

## 25. Иерархия уровней безопасности по оранжевой книге. Понятия идентификации и аутентификации

**Безопасная компьютерная система** - посредством специальных механизмов защиты контроллируется доступ к информации, таким образом, что только имеющие соотсетствующие полномочия лица или процессы, выполняющиеся от их имени, могут получить доступ на чтение, изменение создание или удаление информации.

> Существует 4 основных уровня, но некоторые имеют свои подуровни

### Уровень D

> Когда истема не попадает ни в один из описанных классов

### Уровень C

> Самый слабый из классов безопасности

1. Подсистема идентификации и аутентификации

    - Идентификация - **присвоение** некоторых идентификаторов субъекту

        - То что субъект знает (кодовое слово)
        - То, что субъекту принадлежит (карта, токен)
        - То, что является его неотъемлемой характеристикой (биометрия)

    - Аутентификация - **сопоставление** предъявляемого идентификатора и того, который хранится в системе

    - Авторизация - **назначение** тех или иных прав доступа субъекту, прошедшему аутентификацию

2. Подсистема учёта событий, связанных с безопасностью

3. Изберательный (дискреционный) контроль доступа - в том или ином виде существует матрица вида: субъекты <-> объекты

- ### Уровень C1

4. Разделение пользователей и данных
5. Выделение контцра обеспечения безопасности

Доверенная вычислительная база - совокупность защитных механизмов, включающих аппаратное и программное обеспечение, отвечающих за приведение в жизнь политики безопасности.

> По факту это анличие отдельного прилоэения/процесса, которое будет заниматься исколючиткльно решением задач, связанных с безопасностью

6. Сдерства проверки корректности функционирования аппаратных и программных компонентов вычислительной базы (тест, что машина и программа аутентификации вообще работают)

- ### Уровень C2

7. Журнал контроля доступа к системе (журналируются действия пользователя)
8. Изоляция ресурсов - при выделении объекта из негоко пула ресурсов доверенной вычислительной базы за тем удаляются следы его использования
9. Проводится тестирование на отсутствие видимых недостатков в механизмах

### Уровень B

1. Мандатный доступ - каждому объекту ставится в соответствие метка секретности и какждому объекту тоже ставится такая метка

Субъект имеет право на запись в объекты своего уровня и **выше**

- ### Уровень B1

Мандатное управление доступом к выбранным субъектам и объектам _(не все объекты наделены уровнем доступа)_

- ### Уровень B2

Абсолютно любой субъект и объект должны быть классифицированы и включены в систему управления мандатным доступом

- ### Уровень B3

Поддержка B2, а также включение домена безопасности

Домен безопасности - наличие специального администратора безопасности и системы мониторинга безопасности _(только администратор имеет управление над присвоением классификаций)_

### Уровень A

Поддержка B3, а также формализованные проценуды проектирования, управления и распространения

Проверяем перед построением системы, что её безопасность действительно нельзя нарушить

<br>

## 26. Избирательный (дискреционный) контроль доступа. Ролевой контроль доступа

**Изберательный (дискреционный) контроль доступа** - в том или ином виде существует матрица вида: субъекты <-> объекты

### Методы присвоения дискреционного доступа

1. Система имеет суперпользователя, и только он имеет право устанавливать любые другие права

2. Каждый объект системы имеет привязанного к нему субъекта, называемого владельцем, который может назначать права доступа

3. Субъект с определённым правом доступа может передать это право другому субъекту

> ACL - Access Control List

### Ролевая модель доступа

Дискреционная матрица строится относительно роль <-> объект _(вместо субъект <-> объект)_, а каждый субъект в свою очередь характеризуется совокупностью ролей

<br>

## 27. Мандатный контроль доступа

Мандатный доступ - каждому объекту ставится в соответствие метка секретности и какждому объекту тоже ставится такая метка

Особенности мандатного контроля доступа:

1. Каждый субъект может читать данные со своим уровнем и ниже
2. Каждый субъект может записывать данные в свой уровень и выше

<br>

## 28. Аудит и шифрование данных в БД

### Аудит

**Аудит** — протоколирование действий с ИС

#### Типовые объекты аудита

1. Аутентификация, в том числе неуспешная
2. Завершение сеанса
3. Обращение к объектам
4. Смена привелегий или иных аттрибутов безопасности

#### Возможные стратегии

1. Выборочное протоколирование
2. Адаптивное протоколирование

Здаём некоторые сценарии, в ответ на которые есть возможность переводить систему в разные режимы журналирования

### Шифрование

1. Прозрачное шифрование (Transparent Database Decription)

    При записи на диск, файлы шифруем, при прочтении дешифруем

2. Шифрование на уровне столбцов (Raw Level Enctiprion)

    Нельзя получить доступ к тем аттрибутам, к которым у субъекта нет ключа шифрования

3. Шифрование средствами ФС (File System Encription)

    При записи ФС шифрует данные

4. Хеширование (Application Leven Encription)

    Данные всегда зашифрованы, а шифруются они на стороне приложения

### Резюме

В попытках достичь надёжности-безопасности мы упираемся в производительность и упираемся в полоток.

Поэтому появился тренд на распределённость БД

<br>

## 29. Распределенные БД. Определение. Стратегии размещения данных в системе, их достоинства и недостатки. Понятие прозрачности

### Распределённые ДБ

**Распределённая БД** - это набор логически связанных между собой разделяемых данных и их описаний, которые физически распределены по нескоьким вычислительным узлам.

> Понятно, что нужно разделять таблицы

**Фрагментирование** - это разделение отношения, а получившиеся компоненты называются фрагментами.

#### Типы распределённых БД

1. Гомогенные - одинаковая СУБД на всех узлах
2. Гетерогенные - разные СУБД на узлах

#### Преимущества распределённых БД

1. Может нативно отображать структуру организации
2. Отказоустойчивость?
3. Повышение доступности и надёжности
4. Модульность системы

#### Недостатки распределённых БД

1. Повышение сложности
2. Увеличение стоимости владения
3. Проблема защиты
4. Усложнение контроля за целостностью данных
5. Отсутствие стандартов

### Фрагментироваие

1. Горизонтальное (шардирование) - выделение подмножеств строк

2. Вертикальное - пытаемся хранить таблицу не как кортежи со всеми атрибутаит, а отдельно столбцы (храним на разнызх узлах данные разной секретности)

3. Смешанное - очев (когда есть фрагмент таблицы, который часто используется)

Репликация - поддержка синхронизированных физических копий некоторго объекта БД

### Стратегии размещения данных в распределённой системе

#### 1. Фрагментированное (раздельное) размещение

БД разбиваетсяна непересекующиеся фрагменты, и каждый из фрагментов располагается строго на одном узле

#### 2. Размещение с полной репликацией

На каждом узле есть полная реплика всей БД (олимпа ИТМО по рпоге)

#### 3. Размещение с выборочной репликацией

Разделяем БД тем или иным способом, и для каждого фрагмента решаем 2 задачи:

1. Сколько копий фрагмента сделать
2. Где их прасположить

> СУБД должна принимать данные решения

### Принципы прозрачности СУБД

#### 1. Прозрачность фрагментации

Пользователь не знает ,как фрагментирован тот или иной объект

#### 2. Прозрачность расположения фрагмента

Пользователь не знает ,на каком конкретном узле расположен тот фрагмент, к которому он обращается

#### 3. Прозрачность количества реплик

Пользователь не может обратиться к конкретнной реплике

#### 4. Прозрачность контроля доступа

Пользователь не знает, данных действительно нет или у него нет на них доступа

<br>

## 30. Двенадцать правил Дейта распределенных БД

1. **Локальная автономность**

    Локальные данные принедлежат локальным владельцам и локально сопровождаются (на каждом узле есть свой управленец БД и только он имеет к ним доступ управления)

2. **Отсутствие опоры на центральный узел**

    В системе не должно быть ни одного узла, без которого система не может функционировать

3. **Непрерывное функционирование**

    В системе не должна возникать потребность в плановом останове её функционирования

4. **Независимость от расположения**

    Любой пользователь может получить доступ к данным, хранящимся на любом узле

5. **Независимость от фрагментации**

    Любой пользователь может получить доступ к данным, вне зависимости от их фрагментации

6. **Независимость от репликации**

    Любой пользователь может получить доступ к данным, вне зависимости от наличия реплик

7. **Обработка распределённых запросов**

    Любой пользователь должен иметь возможность обработать любой запрос вне зависимости от количества узлов, на которых расположены запрашиваемые объекты данных

8. **Обработка распределённых транзакций**

    Система должна поддерживать выполнение транзакций с данными, расположенными более чем на одном узле

9. **Независимость от типа оборудования**

    Очев

10. **Независимость от сетевой архитектуры**

    Очев

11. **Независимость от операционной системы**

    Очев

12. **Независимость от типа СУБД**

    Очев

<br>

## 31. Предпосылки к появлению NoSQL баз данных

1. `BigData` - в последнее время началась работа со слишком большим количеством данных

2. Взяимосвязанность данных (косвенные связи) - сопоставив несколько разных баз данных, можно получить новые связи

3. Использование слабо-структурирвоанной информации (очень много конфигураций даже в рамках одной группы)

    - например, фильтры поиска телефона, где какие-то атрибуты могут присутствовать только у одного бренда, в связи с чем хранение такого массива данных в SQL таблице приводит к огромному количеству null значений и неиспользуемых аттрибутов

4. Изменение в архитектурах информационныъ систем - когда граф становится полносвязным, SQL становится очень неэффективным

> Если не получается сделать распределённую систему, давайте тогда **распределим ресурсы**

<br>

## 32. Общие характеристики NoSQL баз данных

1. Отказ от стандарта SQL (он есть, но со множеством отхождений)

2. Schemaless (неструктурированность)

    Мы можем менять что-то в структуре данных уже по дороге

3. Aggregates

    Впротивовес нормализованным SQL решениям мы пытаемся хранить данные как можно более сгруппированными _(отмена декомпозиции)_

    - Это связано с тем, что зачастую из миллиардов возможных комбинаций SQL запросов (аггрегатов таблиц), зачастую используется 30-50, отсюда и идея о том, чтобы сразу хранить данные в таком виде, в котором их было бы удобно запрашивать

    - Минус заключается в том, что при NoSQL, когда, всё-таки, приходится делать аггрегат данных, приходится фактически просматривать полностью всю базу данных для построения результата запроса

4. Weak ACID (Atomicity, Consistenss, Isolation, Durability)

    Транзакция в базе перестаёт сохранять указанные для неё в SQL свойства.

    - На смену ACID пришла другая модель BASE (Basic Avialability, Sost State, Eventual Consistens)

### BASE модель

1. Каждый запрос гарантированно завершается
2. Система может изменять данные даже без ввода или изменения данных извне
3. Конечная непротиворечимость

<br>

## 33. CAP теорема. Пример

В распределённой информационной системы возможно обеспечить не более двух из перечисленных свойств _(Consistency, Availability, Partition tolerance)_

![CAP-треугольник](../Images/cap-theorem.png)

### Целостность

- Во всех узлах в один момент времени данные не противоречат друг другу

- Два запроса в один момент времени к двум разным узлам, то результат выполнения обоих откликов будет одинаков

> Одинаковые результаты с любого узла в один момент времени

### Доступность

- Любой запрос к распределённой системе завершаеся корректным откликом в пределах заданного интервала времени, однако без гарантии, что отклики от всех узлов совпадут

### Устойчивость к распределению

- Расщепление распределённой системы на несколько изолированных секций не приводит к некоррекности отклика от каждой из секций

> CAP - треугольник

> Все реляционные БД - это `CA-системы`

___

### Пример

#### 1. Централизованная система

![Централизованная система](../Images/%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0.png)

Является C системой, так как всего один источник правды — + Consistency.

#### 2. Решение — нанять компаньона (нет взаимосвязи между обработчиками)

![А-система](../Images/%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0.jpg)

Является A системой, так как при неисправности одного обработчика, может работать другой — +Availability.

Однако теряем Consistency, так как нету связи между источниками правды.

#### 3. Принимаем решение о согласовании данных (Распределённая система с транзакционной репликацией данных)

![Транзакционная репликация](../Images/%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.jpg)

Проблема доступности при недоступности хотя бы одного узла (пользователь ждёт пока я согласую ему запись, пока сам жду ответа от недоступного узла, так как он недоступен по каким-то причинам)

#### 4. Распределение системы

  1. Распределённая система с гарантированной репликацией данных

      При звонке клиента пингуем второй узел на доступность. Если получем понг, то согласуем с ним данные, если нет, то кладём изменения в какую-то общую очереь и продолжаем работать.

      Когда узел поднимется, он первым делом из очереди прочитает изменения.

      Это CA система. Но нет Partition tolerance. Так как для соблюдения РТ нужен гарантированный канал связи. Если не пришёл отклик от узла, мы не знаем, это нет связи или узел действительно неактивен. Если положим в очередь, а на самом деле просто не было связи, когда связь восстановится, узел не будет знать о том, что в очереди что-то есть (так как он продолжал работать, просто связи не было). Таким образом получим некорректный отклик при разделении узлов.

  2. Распределённая система с гарантированным откликом

      Целостность данных в конечном счёте.
      AP система.

      После разговора с клиентом сразу рассылаю на все узлы в буфер данные, которые только что получил.

      Все узлы с какой-то переодичностью разбирают свои буферы.
      Тогда на длительном промежутке консистентность будет

  3. Распределённая система с гарантированной целостностью данных

      СР система.
      Невозможно обеспечить полную доступность.

      Блокируем запросы клиентов, если не удаётся подтведрдить статус узла.

<br>

## 34. NoSQL решения: хранилища ключ-значение и документоориентированные БД

<br>

## 35. NoSQL решения: колоночные и графовые БД

<br>

## 36. База знаний. Определение, отличие от базы данных, замкнутые и открытые БЗ

<br>

## 37. Логическая модель представления знаний

<br>

## 38. Сетевая модель представления знаний, семантическая сеть, онтология

<br>

## 39. Фреймовая модель представления знаний

<br>

## 40. Продукционная модель представления знаний
