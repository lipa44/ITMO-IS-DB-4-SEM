# Лекция 8

# Вступление

Поговорили про производительность, рассмотрев индексы и представления в качестве решения возникших проблем.

## Постановка задач

Основная задача - хранение, и обеспечение надёжности хранения подразумевает:

1. Надёжность хранения - если мы единожды сохранили данные, то через любой промежуток времени, через который мы прочитаем эти данные, данные окажутся теми же

2. Надёжность доступа - блокировка данных при высокой нагрузке

Мы рассматриваем надёжность как обеспечеие целостности и надёжности данных на всём промежутке использования

Когда мы говорим про целостность данных, то мы должны задумываться как о **физической**, так и о **логической** сохранности.

> Любое аппаратное решение лучше программного

**СХД** - система хранения данных, очень сложная и цзкоспециализированная система

**ЦОД** - центр обработки данных

# Надёжность

Вопрос надёжности сводится к одному единственному инструменту - транзакции

## Виды целостости данных

1. Физическая целостность _(стандарт TIER)_

2. Логическая целостность _(сложно контроллировать)_

## Транзакции

Транзакция - последовательность действий с базой данных, в которой либо все действия выполняются успешно, либо не выполняется ни одно из них. 

> По факту это преобразование бд из одного логически-согласованного состояния в другое логически-согласованного состояния, подразумевая, что в промежутке бд могла находиться в логически-несогласованном состоянии

### Свойства транзакций

Выполнение всех четырёх свойств одновременно гарантирует надёжность операций

1. Атомарность - транзакция неделима, т.е. либо выполняются все её действия, либо ни одного

2. Согласованность - транзакция переводит одно согласованное состояние бд в другое без соблюдения обязательной согласованности в промежуточных точках

3. Изоляция - если запущено несколько конкурирующих транзакций, то любое обновление состояния бд, выполненное одной транзакцией, скрыто от других до её завершения

4. Долговечность - когла транзакция завершена, её результаты обновления сохраняются, даже если в следующий момент произовдёт сбой

### Проблемы конкурирующих транзакций

1. Проблема потерянного обновления - несколько транзакций меняют один и тот же кортеж, в результате сохраится только резльтат внесения изменений последенй транзакции.

> Кладём и списываем деньги со всёта

2. Проблема грязного чтения - при чтении одной транзакции кортежа, который уже изменён, но ещё не сохранён другой уже завершившейся транзакцией, которая будет потом отменена.

> Кладём и списываем деньги со счёта, после этого пытаемся отменить пополнение

3. Проблема неповторяемого чтения - при повторном чтении данных, уже считанных ранее, транзакция обнаруживает модификацию, вызванную другой завершённой транзакции.

4. Проблема фантомного чтения - 

> Сначала считываем данные, потом добавляем новую запись и на основе считанных данных получаем неверный результат (например, среднее значение в параллельных подзапросах)

### Блокировки

> Все транзакции строятся на основе блокировок - блокировки кортежей, аттрибутов, таблиц или всей базы данных

#### Классификация блокировок

1. Явные (накладывающиеся пользователем)

2. Неявные (накладывающиеся самой СУБД)

3. Монопольные - блокируются все виды доступа к объектам

4. Коллективные - блокируются доступ к чтению? к объектам

Дедлоки

> Если одна из транзакций пытается наложить блокировку, пересекающиеся с какой-то другой блокировкой - появление **дедлоков**

### Уровни изоляции (для решения конкурирующих транзакций)

1. Незавершённое чтение - требует, чтобы изменять данные могла только одна транзакция. Поможет справиться с **проблемой потерянного обновления**.

2. Завершённое чтение - если транзакция начала изменение данных, то никакая другая транзакция не сможет их прочитать до завершения первой. Поможет справитсья с **проблемой грязного чтения**.

3. Воспроизводимое чтение - если транзакция считывает данные, то никакая другая транзакция не сможет их изменить до завершения первой. _Видимо_, поможет справиться с **проблемой неповторяемого чтения**

4. Сериализуемость - если транзакция обращается к данным, то никакая другая транзакция не сможет добавить новые или изменить существующие кортежи в этом объекте данных. _Видимо_, поможет справиться с **проблемой фантомного чтения**

### Долговечность

Обеспечивается журналируемостью транзакций